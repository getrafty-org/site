---
title: "Async I/O - Sockets"
publishedAt: "2025-09-11"
summary: "Build reliable message transport over TCP. Learn about framing, buffering, and handling partial reads/writes."
prev: "async-io-1"
next: "thread-pool"
---

Alright, so we've got an event loop that can schedule I/O operations. 
That sounds too far from our original goal of being able to "talk" to a remote machine doesn't it? 
Bear with me. I promise this will makes sense once we outline another corner pice of BarkFS's networking stack.


## Talking Machines

In Unix world, talking to a remote machine means doing read or write operation. There're many ways how we can do that but
the fundamental job of OS is to provide abstractions over hardware devices for us programmers to efficiently use them. 
For network devices this abstraction is [sockets](https://en.wikipedia.org/wiki/Berkeley_sockets). Hello from 80s. 
A socket is basically the OS handing you a handle and saying: "use this to send bytes out". 
Every major operating system has this concept.

We will build BarkFS's networking stack on top of non-blocking sockets and here is where reactor we built earlier comes into play.

## Message Passing

What we're building here is the foundation of a distributed system. 
Think about what Raft nodes need to do - they send messages to each other constantly. 
Vote requests, log replication, heartbeats. 
Each message needs to arrive intact, in order, without corruption.

You could use an existing RPC framework - [gRPC](https://grpc.io/), [Thrift](https://thrift.apache.org/), [Cap'n Proto](https://capnproto.org/). 
They all solve this problem. But we here for learning, so it's fun to build from first principles.

A communication library typically has these pieces:

1. Transport layer: Handles raw socket I/O, connection management, error handling
2. Framing layer: Turns byte streams into messages with boundaries
3. Codec layer: Serialization/deserialization of your data structures
4. RPC layer: Request/response matching, timeouts, error propagation

In this article we're focused on pieces 1 and 2. 
Getting bytes onto the wire reliably, and recovering structured messages on the other end.

## Framing

The gap between "stream of bytes" and "stream of messages" is called framing. 
Every network protocol needs it. Things like length prefixed encoding, 
new line delimiters or fixed size message encoding are all used to solve it.. 

We're going with length prefixing. 
It handles arbitrary binary data, it's simple to implement, and it's what you'll find in production systems. 
Four bytes at the start of each message saying "the next N bytes are a complete message."

## Transport

Sockets are lower level than we want to deal with directly. So we introduce an abstraction: transports. A transport handles the nitty-gritty of reading and writing, buffering, error handling, and all that. Our code just says "send this message" or "give me the next message."

Here's the interface:

```cpp
class ITransport {
public:
    // Lifecycle
    virtual void attach(EventWatcher& ew, Fn<IOEvent&&> replay) = 0;
    virtual void bind() = 0;      // Server-side
    virtual void connect() = 0;   // Client-side
    virtual void close() = 0;

    // I/O
    virtual size_t resumeRead(Buffer& out_data, Peer& out_peer,
                             IOStatus& out_status, size_t offset,
                             size_t max_len) noexcept = 0;
    virtual void suspendRead() = 0;

    virtual size_t resumeWrite(Buffer&& data, const Peer& peer,
                              IOStatus& out_status) noexcept = 0;
    virtual void suspendWrite(const Peer& peer) = 0;
};
```

The "resume/suspend" pattern is interesting. Instead of "read" and "write" directly, you *resume* reading or writing. The transport does its work, then suspends itself until the next event. This fits nicely with the event loop model - the transport doesn't block, it just does what it can and yields control.

## ðŸ§  Task

In [`tasks/socket/`](https://github.com/getrafty-org/getrafty/tree/main/tasks/socket) you'll find:

- `tcp_transport.cpp` - Handles raw TCP socket I/O
- `framed_transport.cpp` - Adds length-prefix framing on top of TCP

The goal for today is to implement the missing pieces in `framed_transport.cpp` like:

```cpp
void FramedTransport::attach(io::EventWatcher& ew, Fn<IOEvent&&> replay) {
  // ==== YOUR CODE: @148d ====

  // ==== END YOUR CODE ====
}
```

Specifically:

- Implement frame encoding/decoding with 4-byte length prefix
- Handle partial reads (accumulate bytes until you have a complete frame)
- Handle partial writes (buffer unsent bytes, resume when socket is ready)
- Manage per peer buffers

The TCP layer is already done. You're just adding the framing logic on top.

## ðŸ“¦ Build & Test

Tests in [`socket_test.cpp`](https://github.com/getrafty-org/getrafty/blob/main/tasks/socket/socket_test.cpp).

```shell
~/$ ./tasklet test socket
```

There's also a benchmark that measures ping-pong latency:

```shell
~/$ ./tasklet bench socket
```

To give you a rough baseline, on my machine with my own rough implementation 
I was able to achieve around 19 Î¼s mean latency / 105k RPS for 64 byte messages and 1ms / 29k RPS for 264Kb messages.

```shell
~/$ lscpu
Architecture:                x86_64
    CPU op-mode(s):          32-bit, 64-bit
CPU(s):                      8
    Thread(s) per core:      2
    Core(s) per socket:      4
    CPU max MHz:             4200.0000
```


## What's Next?

With reliable message transport in place, we can build higher-level protocols. Next up: RPC. Taking a function call and shipping it across the network, getting a response back. All the fun of distributed systems - timeouts, retries, backpressure, you name it.
